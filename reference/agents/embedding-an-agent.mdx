---
title: Embedding an agent
description: Learn how to embed deployed agents in different environments and integrate them with external systems
---

# Embedding an agent

Once your agent is deployed, you can embed it in various environments and integrate it with external systems to automate research and decision-making across your tech stack.

## Embedding options

### API integration

The most common way to embed agents is through REST API calls. Each deployed agent exposes a dedicated endpoint that accepts input data and returns research results.

```bash
curl -X POST https://api.getcargo.ai/v1/agents/{agent_id}/run \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "company_name": "Acme Corp",
    "domain": "acme.com"
  }'
```

### Webhook triggers

Configure agents to trigger automatically when specific events occur in your systems:

- **CRM updates:** When a new lead is created or contact information changes
- **Form submissions:** When prospects fill out qualification forms
- **Database changes:** When records are added or modified
- **External API calls:** When third-party services send data

### SDK integration

Use Cargo's SDKs to integrate agents directly into your applications:

```javascript
// JavaScript/Node.js
import { CargoAgent } from '@getcargo/sdk';

const agent = new CargoAgent('your-agent-id', 'your-api-key');
const result = await agent.run({
  company_name: 'Acme Corp',
  domain: 'acme.com'
});
```

```python
# Python
from cargo_sdk import CargoAgent

agent = CargoAgent('your-agent-id', 'your-api-key')
result = agent.run({
    'company_name': 'Acme Corp',
    'domain': 'acme.com'
})
```

---

## Environment configurations

### Development environment

For testing and development, use sandboxed agents with limited data access:

- **Test data only:** Use sample datasets for development
- **Rate limiting:** Prevent excessive API calls during development
- **Logging:** Enable detailed logs for debugging
- **Mock responses:** Use simulated responses for faster iteration

### Staging environment

Configure agents for pre-production testing:

- **Limited production data:** Access to subset of real data
- **Performance monitoring:** Track response times and accuracy
- **Error handling:** Test failure scenarios and recovery
- **Integration testing:** Verify connections with other systems

### Production environment

Deploy agents with full production capabilities:

- **Full data access:** Connect to all authorized data sources
- **High availability:** Ensure 24/7 uptime and reliability
- **Security:** Implement proper authentication and authorization
- **Monitoring:** Real-time performance and health tracking

---

## External system integration

### CRM systems

Integrate agents with popular CRM platforms:

**Salesforce**
- Use Salesforce Flow to trigger agents on record changes
- Store agent responses in custom fields
- Create automated follow-up actions based on research results

**HubSpot**
- Connect via webhooks for real-time lead qualification
- Use custom properties to store agent insights
- Automate email sequences based on research findings

**Pipedrive**
- Trigger agents when deals are created or updated
- Enrich contact records with agent research
- Create automated tasks based on qualification results

### Marketing automation

Connect agents to marketing platforms for intelligent lead scoring:

**Marketo**
- Use webhooks to trigger research on new leads
- Update lead scores based on agent findings
- Create dynamic content based on research results

**Mailchimp**
- Trigger research when subscribers are added
- Segment audiences based on agent insights
- Personalize campaigns with research data

### Data warehouses

Store and analyze agent research results:

**Snowflake**
- Create dedicated tables for agent responses
- Build dashboards to track research trends
- Use SQL to analyze patterns in agent findings

**BigQuery**
- Stream agent results to BigQuery datasets
- Create ML models based on historical research
- Generate reports on research effectiveness

---

## Authentication and security

### API keys

Generate and manage API keys for secure access:

- **Read-only keys:** For retrieving research results only
- **Full-access keys:** For running agents and managing configurations
- **Environment-specific keys:** Separate keys for dev/staging/production
- **Key rotation:** Regular key updates for security

### OAuth integration

For enterprise environments, implement OAuth 2.0:

- **Single sign-on:** Integrate with existing identity providers
- **Role-based access:** Control agent access by user roles
- **Audit trails:** Track who accessed which agents
- **Compliance:** Meet enterprise security requirements

### Rate limiting

Configure appropriate rate limits for your use case:

- **Per-agent limits:** Control calls to individual agents
- **Per-user limits:** Limit calls per authenticated user
- **Time-based limits:** Prevent excessive usage in time windows
- **Cost management:** Align limits with your pricing plan

---

## Monitoring and observability

### Response tracking

Monitor agent performance and reliability:

- **Response times:** Track how quickly agents return results
- **Success rates:** Monitor percentage of successful runs
- **Error rates:** Identify and resolve common failures
- **Data quality:** Assess accuracy of research results

### Usage analytics

Understand how agents are being used:

- **Call frequency:** Track how often agents are called
- **Input patterns:** Analyze common input data
- **Output trends:** Identify patterns in research results
- **User behavior:** Understand how teams use agents

### Health monitoring

Ensure agents remain operational:

- **Uptime monitoring:** Track agent availability
- **Data source health:** Monitor external data connections
- **Performance alerts:** Get notified of issues
- **Automated recovery:** Self-healing for common problems

---

## Best practices

### Error handling

Implement robust error handling for agent calls:

- **Timeout handling:** Set appropriate timeouts for agent responses
- **Retry logic:** Automatically retry failed calls with exponential backoff
- **Fallback responses:** Provide default responses when agents fail
- **Error logging:** Capture detailed error information for debugging

### Performance optimization

Optimize agent integration for speed and efficiency:

- **Caching:** Cache common research results to reduce API calls
- **Batch processing:** Group multiple requests when possible
- **Async processing:** Use non-blocking calls for better performance
- **Connection pooling:** Reuse connections for multiple calls

### Data management

Handle data efficiently and securely:

- **Input validation:** Validate data before sending to agents
- **Output processing:** Parse and validate agent responses
- **Data retention:** Implement appropriate data retention policies
- **Privacy compliance:** Ensure data handling meets privacy requirements

---

## Common integration patterns

### Real-time qualification

Trigger agents immediately when new data arrives:

1. **Event occurs:** New lead created, form submitted, etc.
2. **Agent triggered:** Automatically call relevant agent
3. **Research completed:** Agent returns qualification results
4. **System updated:** Update CRM, send notifications, etc.

### Batch processing

Process multiple records in batches:

1. **Data collection:** Gather records that need research
2. **Batch submission:** Send multiple records to agent
3. **Parallel processing:** Process records concurrently
4. **Results aggregation:** Collect and organize all results

### Scheduled research

Run agents on a regular schedule:

1. **Schedule defined:** Set up recurring agent runs
2. **Data preparation:** Identify records needing research
3. **Agent execution:** Run agents against prepared data
4. **Results distribution:** Share findings with relevant teams

Each integration pattern serves different use cases and can be combined to create comprehensive automation workflows that leverage agent intelligence across your entire business process.
