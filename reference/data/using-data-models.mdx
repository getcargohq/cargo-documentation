---
title: Using data models
description: Learn how to work with data models, set up relationships, filters, and custom columns
---

## Filters and segment triggers

By applying filters to data models, users can create focused subsets of data within the larger model. For example, a filter could be created to narrow down prospects who were participants in a webinar event.

Enabling a play allows it to respond to real-time changes in the underlying model's data. When an appropriate change is detected, the play can import records from that model to create runs. A play will periodically resync for changes according to a schedule or a 'cron job' (except for webhook-based models, which resync automatically when a new record is added). An appropriate change is triggered whenever a record's data matches the criteria set in the filter, whether due to a record's update, addition, or removal.

Importing records into plays based on these changes allows users to build plays that operate autonomously. For example, in a model containing customer data, records can be imported into a play whenever a new customer is added or when existing customer data is updated.

Another advantage of this system is the ability to track records that enter a play. By maintaining a history of imported records, Cargo prevents plays from creating multiple runs for the same record.

Filter logic can be easily reused across Cargo workspace when saved as segments. Segments are named sets of filters.

---

## Search and upsert in models

Within plays, users have the ability to query data from any model in Cargo, ensuring that the data is accessible and actionable when needed.

This capability allows for one-off data retrieval operations without needing to create any merged views.

In a similar fashion, upserts to a model enable users to push data to custom columns for existing records for transactional data, as it allows for synchronization of data across different systems.

---

## Interacting with storage using nodes

Cargo provides several nodes for interacting with storage and data models:

### Memory node

Store or access structured data using a key/value store approach.

**Options:**
- **Scope:** Whether the key/value should be stored on workspace or workflow level
- **Key:** The unique identifier of the stored value

**Actions:**
- **Get:** Read value from the storage
- **Set:** Write value to the storage
- **Get or set:** Read the value from the storage if available, if not set the provided value for future use
- **Increment:** Increase value of a counter
- **Decrement:** Decrease value of a counter
- **Remove:** Remove key and its value

### Model custom column node

Update custom columns on a selected data model. This node allows writing data to custom columns created on a particular data model. It allows extending the data model that is synchronized from an external system with additional data points. For instance, you may want to add extra metadata about particular records or flag them.

**Options:**
- **Model:** Data model to work with
- **Action:** Upsert which means record will be created when not found
- **Record ID:** Primary identifier of the data model record to update
- **Mappings:** List of pairs of column name and value (e.g., industry: automotive)

The ID required by this node needs to be the primary identifier of the data model. When the workflow is using the same data model, the record ID can be set to `nodes.start._id`. In case no primary ID is available in the workflow, consider using the model search node.

### Model record node

Add record to a compatible data model. Some data models, such as HTTP, allow creating new records from within Cargo's workflows. It can be useful to store new data and trigger other workflows.

Data models coming from external services such as CRM don't support writing records using this node. In order to create new objects, use dedicated write nodes for the service in question (e.g., HubSpot write node).

**Options:**
- **Model:** Data model to add a new record to (must be a compatible data model)
- **Action:** Insert
- **Data:** JSON object with data for the new record

**Example:**
```json
{
  "_id": "${nodes.start._id}",
  "email": "${nodes.start.email}",
  "is_business_email": true
}
```

Ensure all parameters are carefully passed with correct data types. If a new column is created using this node, the first value will determine the data type, which cannot be changed later.

### Model search node

Search and retrieve model or dataset records. This node allows you to query data from any model in your workspace and use the results in your workflow.

---

## Custom columns

Cargo allows users to create custom columns. These columns let you add calculated fields or tags to existing rows in a model.

There are three types of custom columns that you can create in Cargo:

### Custom columns
These columns are free-form columns that you can upsert data into from within a play. For example, you could create a custom column called `last_score_at` to keep track when scoring was performed for a given record and use that information to re-enroll records for additional evaluation in the future.

### Computed columns
These columns are created using storage that calculate values based on other columns in the model. For example, you could create a computed column that classifies customers based on their job title and years of experience whether they are senior or not. The value is computed using Cargo's expression syntax and can only consider other columns of the same data model.

### Metrics columns
These columns are used to store aggregated data, such as sums, averages, or counts, based on the values in other columns in other models. For example, you could create a metrics column inside the Salesforce data model that calculates the total revenue generated by each customer from the Stripe data model.

---

## Model relationships

Relationships between models in Cargo are useful for creating a comprehensive view of your data. By connecting different models using common identifiers, you can create merged views of your customer data from different sources.

Defining relationships involves specifying how records in one model relate to records in another model. This includes determining the type of relationship (such as one-to-one, one-to-many, or many-to-many), and mapping the identifier columns between the models. Relating models to one another can provide richer context for decision-making and workflow triggers.

For instance, consider the example of connecting Salesforce data with Stripe invoice data. By linking the 'SalesforceAccounts' model with the 'StripeInvoices' model using a common identifier such as 'CustomerID', you can create a relationship that combines CRM data with financial data. This integrated view allows you to see how customer interactions in Salesforce relate to their invoicing history in Stripe.
